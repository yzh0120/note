## es5
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};
var p = new Point(1, 2);

## ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已
## es6
class Point {
  constructor(x, y) {
    this.x = x; //在实例 但是不在Point.prototype对象里面
    this.y = y;
  }

  toString() {//即在实例 也在Point.prototype对象里面
    return '(' + this.x + ', ' + this.y + ')';
  }

  static classMethod() {//只在类上
    return 'hello';
  }
}
## 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。
但是constructor() 里面定义的变量不在prototype属性上面!!!
## constructor() 方法
constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。
class Point {
}
// 等同于
class Point {
  constructor(grade) {
    this.grade = grade;
  }
}

## 取值函数（getter）和存值函数（setter） 
class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+value);
  }
}
let inst = new MyClass();
inst.prop = 123;// setter: 123
inst.prop// 'getter'


## 静态方法
静态方法只能类用
class Foo {
  static classMethod() {
    return 'hello';
  }
}
Foo.classMethod() // 'hello'

注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。
class Foo {
  static bar() {
    this.baz();
  }
  static baz() {
    console.log('hello');
  }
  baz() {
    console.log('world');
  }
}
Foo.bar() // hello

父类的静态方法，可以被子类继承。
class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
}

Bar.classMethod() // 'hello'

## 私有方法和私有属性 § ⇧
ES2022正式为class添加了私有属性，方法是在属性名之前使用#表示。

class IncreasingCounter {
  #count = 0;
  get value() {
    console.log('Getting the current value!');
    return this.#count;
  }
  increment() {
    this.#count++;
  }
}
上面代码中，#count就是私有属性，只能在类的内部使用（this.#count
