
Bar.__proto__ == Foo.prototype
## 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super()函数。
class Foo {
  constructor(name) {
      this.name = name
  }
   sayHello() {
    console.log(`Hello, ${this.name}`);
  }
}
//Bar.__proto__ == Foo
//Bar.prototype.__proto__ == Foo.prototype
class Bar extends Foo { 
    constructor(name) {
      super(name);
    }
     find() {
      super.sayHello()
      // return super.name; 但是constructor() 里面定义的变量不在prototype属性上面!!!
    }
}
var a = new Bar("小明")

## 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();
let b = new B();
上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。


## 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。
## 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。
