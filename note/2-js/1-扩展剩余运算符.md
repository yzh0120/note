JavaScript 使用三个点（...）来表示 rest（剩余运算符）和 spread（扩展运算符），但是这两个运算符是不一样的。

个人理解，其根本区别在于两者出现在赋值运算符中的位置不同。

扩展运算符在赋值运算符的右侧，它的作用是将一个数组或对象展开，将其中的元素或属性逐一赋值给新的变量。例如：

const arr = [1, 2, 3];
const [a, b, c] = [...arr];
剩余运算符在赋值运算符的左侧，它的作用是将一个数组或对象的剩余部分捆绑为一个新的数组或对象。例如：

const [a, b, ...rest] = [1, 2, 3, 4, 5];

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 数组的解构

## 默认值
let [foo = true] = [];


# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# 对象的解构也可以指定默认值。 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var { message: msg = 'Something went wrong' } = {};
msg // "Something went wrong"
## 对象的解构也可以指定默认值。 默认值生效的条件是，对象的属性值严格等于undefined。
var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null

## :是赋值给别的变量
## 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
